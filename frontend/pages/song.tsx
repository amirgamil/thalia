import type { NextPage } from "next";
import * as React from "react";
import Head from "next/head";
import { Playground } from "../components/playground";
import styles from "../styles/Home.module.css";
import { Nav } from "../components/nav";
import { Footer } from "../components/footer";
import { Button } from "../components/button";
import { useAppContext } from "../components/context";
import { useQuery } from "react-query";
import { useRouter } from "next/router";
import toast, { Toaster } from "react-hot-toast";
import { createByteArrFromString, getStringFromByteArray } from "../lib/uintHelpers";

interface Song {
    name: string;
    bpm: number;
    id: number;
    //Returns an array of byte32 strings
    notes: string[];
    isDeleted: boolean;
    isMinted: boolean;
}

const mapArrToSong = (arr: any[]): Song => {
    const song: any = {};

    if (typeof arr[0] === "string") {
        song.name = arr[0];
    }

    if (typeof arr[1] === "boolean") {
        song.isMinted = arr[1];
    }

    if (typeof arr[2] === "boolean") {
        song.isDeleted = arr[2];
    }

    if (Array.isArray(arr[3])) {
        song.notes = arr[3];
    }

    if (typeof arr[4] === "number") {
        song.id = arr[4];
    }

    if (typeof arr[5] === "number") {
        song.bpm = arr[5];
    }

    return song as Song;
};

interface NotesTracker {
    oldNotes: string;
    //currentNotes is oldNotes + whatever is added
    currentNotes: string;
}

const Song: NextPage = () => {
    const context = useAppContext();
    const router = useRouter();
    const { id } = router.query;

    const contractExists = context.contract !== undefined;

    const { isLoading, error, data } = useQuery<Song | undefined>(
        "song",
        async () => {
            console.log("contract: ", context.contract);
            if (context.contract && id !== undefined) {
                const dataResult = await context.contract.getSongFromId(id);
                //return a tuple with all of the struct elements
                const result = mapArrToSong(dataResult);
                const musicNotes = getStringFromByteArray(result.notes);
                setRawSongNotes(musicNotes);
                return result;
            }
        },
        { retry: 10, enabled: contractExists }
    );
    const rawStringFromBytes = data ? getStringFromByteArray(data.notes) : "";
    const [rawSongNotes, setRawSongNotes] = React.useState<string>(data ? rawStringFromBytes : "");
    const [oldNotes, setOldNotes] = React.useState<string>(rawStringFromBytes);

    const updateSongCallback = (notes: string) => {
        setRawSongNotes(notes);
    };

    const updateSong = async () => {
        const provider = context.provider;
        const signer = context.signer;
        const contract = context.contract;
        if (provider && signer && contract && data) {
            const contractWithSigner = contract.connect(signer);
            const newNotes = createByteArrFromString(rawSongNotes.substring(data.notes.length));

            if (newNotes) {
                console.log("new: ", newNotes);
                const res = await contractWithSigner.addNotes(id, newNotes);

                const updatedNotes = getStringFromByteArray(res);
                setRawSongNotes(updatedNotes);
                setOldNotes(updatedNotes);
            } else {
                toast("Uh oh, add some notes by typing something before you can commit");
            }
        } else {
            console.error("Could not verify provider or signer or contract");
        }
    };

    //FIXME: prompt to sign in with wallet if not signed in instead of just showing loading screen
    if (isLoading || !context.contract) {
        return (
            <div className={styles.container}>
                <main className={styles.main}>
                    <div className="w-full h-full flex items-center justify-center">
                        <p className="opacity-50">loading...</p>
                    </div>
                    <Footer />
                </main>
            </div>
        );
    }

    //TODO: sometimes this shows instead of loading, figure out what's going on
    if (!data) {
        return (
            <div className={styles.container}>
                <main className={styles.main}>
                    <div className="w-full h-full flex items-center justify-center">
                        <p className="opacity-50">A song is waiting to be created here...</p>
                    </div>
                    <Footer />
                </main>
            </div>
        );
    }

    return (
        <div className={styles.container}>
            <Head>
                <title>Thalia</title>
                <meta name="description" content="Generated by create next app" />
                <link rel="icon" href="/favicon.ico" />
            </Head>

            <Nav />
            <main className={styles.main}>
                <div className="py-4">
                    <h1 className="text-xl font-bold">{data.name}</h1>
                    <h3>BPM: {data.bpm}</h3>
                </div>
                {data.isDeleted ? (
                    <p>This song was sadly deleted :(</p>
                ) : (
                    <>
                        <Playground
                            prevMusicNotes={oldNotes}
                            rawNotes={rawSongNotes}
                            updateSongCallback={updateSongCallback}
                            bpm={data.bpm}
                        />
                        <Button onClick={updateSong}>Commit to the chain</Button>
                    </>
                )}
                <Toaster />
                <Footer />
            </main>
        </div>
    );
};

export default Song;
